#!/usr/bin/python3
# -*- coding: utf-8 -*-

# with <3 by ferry-creator
# GNU GPL V2

# âŸ â…€âˆ‘ nablaâˆ‡ deltaâˆ† intâˆ« andâ‹€ orâ‹ xorâŠ» nandâŠ¼ norâŠ½
#     of/inâˆˆ subsetâŠ‚ exists/existâˆƒ sqrtâˆš2 infinity/inftyâˆž
# waveâˆ¿ deg/degs/degree/degreesÂ°


# f(x) = a+b*x+c*x^2
# f(x) = a + bÂ·x + cÂ·xÂ² 

# f(x) = a+b*x+c*x^(1+2â»3*4567890)+100
# f(x) = a + bÂ·x + cÂ·xÂ¹âºÂ²â»Â³â â´âµâ¶â·â¸â¹â° + 100

LUT = {
  # common
  "*": "Â·", "/": "Ã·",
  "<=|=<": "â‰¤", "=>|>=": "â‰¥", "~": "â‰ˆ", # ~=|=~ is zsh reserved
  "+-": "Â±", "-+": "âˆ“",
  "pi|Pi|PI": "Ï€", "euler|e": "ðž",
  "sqrt|SQRT| sq ": "âˆš",
  # trig
  "tau|Tau|TAU": "Ï„",
  "deg|degree|degrees": "Â°", "phase|phi": "Ï•", "wave": "âˆ¿",
  # linear algebra
  "cross": "Ã—", 
  # calculus
  "del|partial": "âˆ‚", "nabla|grad|gradient": "âˆ‡",
  "delta": "Î´", "Delta|D": "âˆ†", " i ": "ð‘–",
  "goes|goto|->": "â†’", "infinity|infty": "âˆž",
  # logic
  " and | AND ": " â‹€ ", " or | OR ": " â‹ ",
  " xor | XOR ": " âŠ» ", " nand | NAND ": " âŠ¼ ", " nor | NOR ": " âŠ½ ",
  # arrows
  "==>|implies": "â‡’", "equivalent|eq|<==>|<=>": "â‡”",
  # sets
  "naturals|N": "â„•", "integers|ints|Z": "â„¤", "rationals|Q": "â„š",
  "reals|R": "â„", "complex numbers|complex|C": "â„‚",
  " in | belong ": " âˆˆ ", " subset ": " âŠ‚ "
}

# superscript / subscript ---------------------------------
superscript_sym = "á´¬áµƒá´®áµ‡á¶œá´°áµˆá´±áµ‰á¶ á¶¢á´´Ê°á´µâ±á´¶Ê²áµá´¸á´¹áµá´ºâ¿á´¼áµ’á´¾áµ–á´¿áµ€áµ—áµáµ˜áµ›áµ‚Ê·Ë£á¶»"
map_super_sym   = "AaBbcDdEefgHhIiJjklMmNnOoPpRTtUuvWwxz"

subscript_sym = "â‚â‚‘áµ¢â‚’áµ£áµ¤áµ¥â‚“"
map_sub_sym   = "aeioruvx"

superscript_ops = "âºâ»â½â¾â "
subscript_ops   = "â‚Šâ‚‹â‚â‚Žâ „"
map_ops         = "+-()*"

superscript_num = "Â¹Â²Â³â´âµâ¶â·â¸â¹â°"
subscript_num   = "â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚€"
map_num         = "1234567890"

SUPER_MAP = map_super_sym + map_ops + map_num
SUB_MAP   = map_sub_sym   + map_ops + map_num
SUPER   = superscript_sym + superscript_ops + superscript_num
SUB     = subscript_sym   + subscript_ops   + subscript_num

def process_script(expr, activator, MAP, SCRIPT):
  script = {"active": False, "parens": "", "start": 0}
  for x in range(expr.count(activator)):
    for i, char in enumerate(expr):
      if char == activator: # '^' / '_', activates mode
        script['active'] = True
        script['start']  = i
        expr = expr[:i] + expr[i+1:]
      if script['active']:
        o_parens = script["parens"].count('(')
        c_parens = script["parens"].count(')')
        if char == '(' or char == ')':
          script["parens"] += char
        break_mode = False
        if char in " +-*/%=~" or c_parens > 0:
          break_mode = True
        if o_parens != c_parens: # cancel
          break_mode = False
        if break_mode:
          if c_parens > 0:
            # cleanup parens ->
            first = expr[:script["start"]]
            raisd = expr[script["start"]+1:i-2]
            rest  = expr[i-1:]
            expr  = first + raisd + rest
          script = {"active": False, "parens": "", "start": 0}
          break
        if char in MAP:
          mapidx = MAP.index(char)
          expr   = expr[:i-1] + SCRIPT[mapidx] + expr[i:]
  return expr
# ---------------------------------------------------------

import sys
import re

def findall_idxs(search, str, val):
  idxs = []
  for m in re.finditer(re.escape(search), str):
    start = m.start()
    end   = m.end()
    dist = end - start
    idxs.append( [start, end, dist, val] )
  return idxs

if __name__ == "__main__":
  expr = " " + "".join(sys.argv[1:]) + " "
  # superscrpit / subscript
  # expr = process_script(expr, '^', SUPER_MAP, SUPER)
  # expr = process_script(expr, '_', SUB_MAP,   SUB  )

  # LUT logic
  collected_idxs = []
  for key in LUT:
    patterns = key.split('|')
    patterns = filter(lambda x: bool(x),patterns)
    for pat in patterns:
      if pat not in expr:
        continue # early return
      idxs = findall_idxs(pat,expr, LUT[key])
      print("IDXs", idxs)
      for idx in idxs:
        start, end, dist, val = idx
        cnt = 0
        while cnt < len(collected_idxs):
          if(cnt >= 1000): break # safety
          past_idx = collected_idxs[cnt]
          past_start, past_end, past_dist, past_val = past_idx
          print(cnt, "checking", val, past_val)
          if start <= past_start and end > past_start \
          or end >= past_end and start <: # collision!
            print("collision!", val, past_val)
            if dist >= past_dist:
              del collected_idxs[cnt]
          else: # if no collision, increment loop
            cnt += 1
        collected_idxs.append(idx)
        print("collected", list(map(lambda x: x[3],collected_idxs)))
  # insert LUT replacements from collected idxs
  collected_idxs=sorted(collected_idxs, key=lambda x: x[0])
  offset = 0 # input is different length than replacement chars
  for idx in collected_idxs:
    start, end, dist, val = idx
    expr = expr[:start-offset] + val + expr[end-offset:]
    offset += dist-1
  
  #strip
  expr = expr.strip()
  print(expr)
